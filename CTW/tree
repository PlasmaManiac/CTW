import math
import random
from tkinter.filedialog import askopenfilename

from Bio import SeqIO


class Node:
    def __init__(self, sym, prnt, tree, lvl):
        # symbol sequence of that node
        self.symbol = sym

        # the tree in which this Node exists
        self.tree = tree

        # Parent Node
        self.parent = prnt
        # The edges of a node, corresponding to a new node.
        # eg: A => The A branch from current node
        self.children = {"A": None, "C": None, "G": None, "T": None}

        # Counts
        self.counts = {"A": 0, "C": 0, "G": 0, "T": 0}

        # Used to store the weighted probability of the node
        self.probability = 0
        self.weighted_probability = 0

        # The level of the node in the tree
        # level = 0 is the root
        self.level = lvl

    def update_probability_log(self, symbol):
        """When called will calculate the probability of the node"""

        total_count = 0
        for key, count in self.counts.items():
            total_count += count

        self.probability += math.log((self.counts[symbol] + 0.5) / (total_count + 2), 2)  # Base 2 log

        children_prob = 0

        if self.level is not self.tree.depth:
            for key, child in self.children.items():
                if child is not None:
                    children_prob += child.probability
            self.weighted_probability = (
            children_prob + math.log(1 + pow(2, (self.probability - children_prob)), 2) + math.log(1 / 2,
                                                                                                   2))  # log(2,2) is equivalent to multiplying it all 1/2
        else:
            self.weighted_probability = self.probability

    def update_probability(self, symbol):

        total_count = 0
        for key, count in self.counts.items():
            total_count += count

        self.probability *= (self.counts[symbol] + 0.5) / (total_count + 2)

        children_prob = 1
        if self.level is not self.tree.depth:
            for key, child in self.children.items():
                if child is not None:
                    children_prob *= child.probability
            self.weighted_probability = (self.probability + children_prob) / 2
        else:
            self.weighted_probability = self.probability

    def print(self, tab):
        # Todo: Print self, based on the depth of the node and  children
        print(tab * self.level, self.symbol, "Prob: " + str(self.weighted_probability))

        for key, child in self.children.items():
            if child is not None:
                child.print(tab)
        return


class Tree:
    def __init__(self, name, depth):
        self.name = name
        self.root = Node("root", None, self, 0)
        self.depth = depth

    def add_data_point(self, symbol, context):
        """Will add the data point to tree."""
        dirty_nodes = self.traverse_context(symbol, context)
        self.reweight_tree(dirty_nodes, symbol)

    def read_file(self, file):

        file_seq = file.seq

        print(file_seq)

        context = []

        for index, symbol in enumerate(file_seq):
            if len(context) is not self.depth:
                #  Add to the context
                context.insert(0, symbol)
            else:
                #  Add to the tree
                #  print("context: ", context)
                #  print("symbol: ", symbol)

                self.add_data_point(symbol, context)

                context.pop()
                context.insert(0, symbol)

    def reweight_tree(self, dirtynodes, symbol):

        self.root.counts[symbol] += 1

        for node in dirtynodes:
            node.update_probability_log(symbol)

        self.root.update_probability_log(symbol)

    def traverse_context(self, symbol, context):
        # Start at the root
        current_node = self.root
        full_path = ""
        dirty_nodes = []
        depth = 1
        # For Each symbol in the context, traverse down from the root.
        for sym in context:
            full_path += sym
            if current_node.children[sym] is not None:
                current_node = current_node.children[sym]
            else:
                current_node.children[sym] = Node(sym, current_node, current_node.tree, depth)
                current_node = current_node.children[sym]

            depth += 1
            dirty_nodes.insert(0, current_node)
            current_node.counts[symbol] += 1

        return dirty_nodes

    def print(self, tab):
        print("Root: ", self.root.probability, " ", self.root.counts)

        for key, child in self.root.children.items():
            if child is not None:
                child.print(tab)

    def commands(self, command):
        # Adds a random sequence to the tree
        if command == "r" or command == "R":
            print("    Random:")
            context = []
            for x in range(0, self.depth):
                context.append(random.randint(1, 4))
            context = int_to_ACGT(context)
            symbol = num_to_ACFT(random.randint(1, 4))
            self.add_data_point(symbol, context)
            print(context, "  symbol: ", symbol)

        # Print out the tree
        elif command == "p" or command == "P":
            print("     Print:")
            self.print(input('     Enter your tab char: '))

        elif command == "l" or command == "L":
            print("Loading from GenBank: ")

            filename = askopenfilename()

            print(filename)

            record_iterator = SeqIO.parse("ls_orchid.gbk", "genbank")

            first_record = next(record_iterator)
            #  print(first_record)
            self.read_file(first_record)

            record_iterator.close()

        elif command == "c" or command == "C":
            print_tree_commands()

def int_to_ACGT(int_list):
    """Helper Function - Allows for the randomly generated sequence to be converted into chars"""
    ACGT_list = []
    for x in int_list:
        if x == 1:
            ACGT_list.append("A")
        elif x == 2:
            ACGT_list.append("C")
        elif x == 3:
            ACGT_list.append("G")
        elif x == 4:
            ACGT_list.append("T")

    return ACGT_list

def num_to_ACFT(x):
    if x == 1:
        return "A"
    elif x == 2:
        return "C"
    elif x == 3:
        return "G"
    elif x == 4:
        return "T"

def print_tree_commands():
    print("Commands:")
    print("a - Add a node")
    print("r - Add random node")
    print("p - Print tree")
    print("l - Load file into tree")
    print("c - Show commands")
    print("x - Exit current tree")

def print_commands():
    print("Commands:")
    print("a - Add a new tree")
    print("o - Open an existing tree")
    print("s - List existing trees")
    print("d - Delete a tree")
    print("c - show commands")


def print_trees(trees):

    print("\n Listing all current trees: ")
    print("\t Name:","\t Depth", "\t\t| Root Prob.")
    print("\t ______________________")
    for key in trees:
        print("\t", key,"\t \t", trees[key].depth, "\t\t" ,trees[key].root.probability)


def main():
    # Allows for user input to interact with the functions above
    test_tree = Tree("Test", 5)

    trees = dict()
    current_tree = None

    trees[test_tree.name] = test_tree

    # Table of commands
    print_commands()

    print_trees(trees)

    while 1:

        if current_tree is None:

            command = input('Enter your command: ')
            if command == "a":
                tree_name  = input("Name of the new tree: ")
                depth_name = input("Depth:")
                trees[tree_name] = Tree(tree_name,int(depth_name))
                print_trees(trees)

            elif command == "o":
                name = input("\tWhich tree do you want to open?\n\t")
                current_tree = trees[name]
                print_tree_commands()

            elif command == "s":
                print_trees(trees)

            elif command == "d":
                name = input("\tWhich tree do you want to remove?\n\t")
                trees.pop(name, None)
                print_trees(trees)

            elif command == "c":
                print_commands()

        else:
            print("\n Currently in tree: ",current_tree.name)
            command = input("\t Enter your command: ")

            if command is "x" or command is "X":
                current_tree = None
                print_trees(trees)

            else:
                current_tree.commands(command)


if __name__ == "__main__": main()
