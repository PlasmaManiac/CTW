import random
import gzip
import math

from Bio.Seq import Seq
from Bio import SeqIO

class Node:
    def __init__(self, sym, prnt, tree, lvl):
        # symbol sequence of that node
        self.sequence = sym

        # the tree in which this Node exists
        self.tree = tree

        # Parent Node
        self.parent = prnt
        # The edges of a node, corresponding to a new node.
        # eg: A => The A branch from current node
        self.children = {"A": None, "C": None, "G": None, "T": None}

        # Counts
        self.counts = {"A": 0, "C": 0, "G": 0, "T": 0}

        # Used to store the weighted probability of the node
        self.probability = 0 # changed
        self.weighted_probability = 0 # Changed

        # The level of the node in the tree
        # level = 0 is the root
        self.level = lvl

    def update_probability_log(self, symbol):
        """When called will calculate the probability of the node"""

        total_count = 0
        for key, count in self.counts.items():
            total_count += count

        self.probability += math.log((self.counts[symbol] + 0.5) / (total_count + 2), 2) # Base 2 log
        # changed

        children_prob = 0
        # changed

        if self.level is not self.tree.depth:
            for key, child in self.children.items():
                if child is not None:
                    children_prob += child.probability
            self.weighted_probability = (children_prob + math.log(1 + pow(2,(self.probability - children_prob)),2)  + math.log(1/2, 2))  # log(2,2) is equivalent to multiplying it all 1/2
        else:
            self.weighted_probability = self.probability

    def update_probability(self, symbol):

        total_count = 0
        for key, count in self.counts.items():
            total_count += count

        self.probability *= (self.counts[symbol] + 0.5) / (total_count + 2)

        children_prob = 1
        if self.level is not self.tree.depth:
            for key, child in self.children.items():
                if child is not None:
                    children_prob *= child.probability
            self.weighted_probability = (self.probability + children_prob) / 2
        else:
            self.weighted_probability = self.probability

    def print(self, tab):
        # Todo: Print self, based on the depth of the node and  children
        print(tab * self.level, self.sequence, "Prob: " + str(self.weighted_probability))

        for key, child in self.children.items():
            if child is not None:
                child.print(tab)
        return


class Tree:
    def __init__(self):
        self.root = Node("root", None, self, 0)
        self.depth = 5

    def add_data_point(self, symbol, context):
        """Will add the data point to tree. Returns true if it already existed, false if not"""
        dirty_nodes = self.traverse_context(symbol, context)
        self.reweight_tree(dirty_nodes, symbol)

    def read_file(self, file):

        file_seq = file.seq

        print(file_seq)

        context = []
        symbol = ""
        for index, symbol in enumerate(file_seq):
            if len(context) is not self.depth:
                #  Add to the context
                context.insert(0, symbol)
            else:
                #  Add to the tree
                print("context: ", context)
                print("symbol: ", symbol)

                context.pop();
                context.insert(0, symbol)

                self.add_data_point(symbol,context)

        return False

    def reweight_tree(self, dirtynodes, symbol):

        self.root.counts[symbol] += 1

        for node in dirtynodes:
            node.update_probability_log(symbol)

        self.root.update_probability_log(symbol);

    def traverse_context(self, symbol, context):
        # Start at the root
        current_node = self.root
        full_path = ""
        dirty_nodes = []
        depth = 1
        # For Each symbol in the context, traverse down from the root.
        for sym in context:
            full_path += sym
            if current_node.children[sym] is not None:
                current_node = current_node.children[sym]
            else:
                current_node.children[sym] = Node(sym, current_node, current_node.tree, depth)
                current_node = current_node.children[sym]

            depth += 1
            dirty_nodes.insert(0, current_node)
            current_node.counts[symbol] += 1

        return dirty_nodes


        # Add in the probabilty update so as the recursion deconsturcts it updates the probability

    def print(self, tab):
        print("Root: ", self.root.probability, " ", self.root.counts)

        for key, child in self.root.children.items():
            if child is not None:
                child.print(tab)


def int_to_ACGT(int_list):
    """Helper Function - Allows for the randomly generated sequence to be converted into chars"""
    ACGT_list = []
    for x in int_list:
        if x == 1:
            ACGT_list.append("A")
        elif x == 2:
            ACGT_list.append("C")
        elif x == 3:
            ACGT_list.append("G")
        elif x == 4:
            ACGT_list.append("T")

    return ACGT_list


def num_to_ACFT(x):
    if x == 1:
        return "A"
    elif x == 2:
        return "C"
    elif x == 3:
        return "G"
    elif x == 4:
        return "T"

def print_commands():
    print("Commands:")
    print("a - Add a node:")
    print("r - Add random node:")
    print("p - Print tree:")
    print("l - load file")
    print("c - show commands")

def main():
    # Allows for user input to interact with the functions above
    test_tree = Tree()

    # Table of commands
    print_commands()

    while 1:
        command = input('Enter your command: ')

        # Add a specific sequence
        if command == "a" or command == "A":
            print("    Add:")
            # TODO: Add a way to capture a sequence of inputs

        # Adds a random sequence to the tree
        elif command == "r" or command == "R":
            print("    Random:")
            context = []
            for x in range(0, test_tree.depth):
                context.append(random.randint(1, 4))
            context = int_to_ACGT(context)
            symbol = num_to_ACFT(random.randint(1, 4))
            test_tree.add_data_point(symbol, context)
            print(context, "  symbol: ", symbol)

        # Print out the tree
        elif command == "p" or command == "P":
            print("     Print:")
            test_tree.print(input('     Enter your tab char: '))

        elif command == "l" or command == "L":
            print("Loading from GenBank: ")

            record_iterator = SeqIO.parse("ls_orchid.gbk", "genbank")

            first_record = next(record_iterator)
            #  print(first_record)
            test_tree.read_file(first_record)

        elif command == "c" or command == "C":
            print_commands()

if __name__ == "__main__": main()
