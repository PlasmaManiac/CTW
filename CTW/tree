import math
import random
import sys
import gzip

from tkinter.filedialog import askopenfilename
from Bio import SeqIO


def print_tree_commands():
    print("Commands:")
    print("a - Add a node")
    print("r - Add random node")
    print("p - Print tree")
    print("l - Load file into tree")
    print("c - Show commands")
    print("x - Exit current tree")


def print_commands():
    print("Commands:")
    print("a - Add a new tree")
    print("o - Open an existing tree")
    print("s - List existing trees")
    print("d - Delete a tree")
    print("c - show commands")


class Node:
    def __init__(self, sym, prnt, tree, lvl):
        # symbol sequence of that node
        self.symbol = sym

        # the tree in which this Node exists
        self.tree = tree

        # Parent Node
        self.parent = prnt
        # The edges of a node, corresponding to a new node.
        # eg: A => The A branch from current node
        self.children = {"A": None, "C": None, "G": None, "T": None}

        # Counts
        self.counts = {"A": 0, "C": 0, "G": 0, "T": 0}

        # Estimated probability given the KT Estimator
        self.estimated_probability = 0

        # Used to store the weighted probability of the node
        self.weighted_probability = 0

        # The level of the node in the tree
        # level = 0 is the root
        self.level = lvl

    def get_weighted_prob(self, depth):

        if depth is 0:
            return self.estimated_probability
        else:
            children_prob = 0
            for key, child in self.children.items():
                if child is not None:
                    children_prob += child.get_weighted_prob(depth - 1)

        return children_prob + math.log(1 + pow(2, (self.estimated_probability - children_prob)), 2) + math.log(1/2, 2)

    def update_probability_log(self, symbol):
        """When called will calculate the probability of the node"""

        total_count = 0

        for key, count in self.counts.items():
            total_count += count

        # Base 2 log
        self.estimated_probability += math.log((self.counts[symbol] + self.tree.alpha)
                                               / (total_count + 4*self.tree.alpha), 2)

        children_prob = 0

        if self.level is not self.tree.depth:
            for key, child in self.children.items():
                if child is not None:
                    children_prob += child.weighted_probability
            # log(2,2) is equivalent to multiplying it all 1/2
            self.weighted_probability = (
                children_prob
                + math.log(1 + pow(2, (self.estimated_probability - children_prob)), 2)
                + math.log(1 / 2, 2))
        else:
            self.weighted_probability = self.estimated_probability

    def update_probability(self, symbol):

        total_count = 0
        for key, count in self.counts.items():
            total_count += count

        self.estimated_probability *= (self.counts[symbol] + 0.5) / (total_count + 2)

        children_prob = 1
        if self.level is not self.tree.depth:
            for key, child in self.children.items():
                if child is not None:
                    children_prob *= child.probability
            self.weighted_probability = (self.estimated_probability + children_prob) / 2
        else:
            self.weighted_probability = self.estimated_probability

    def print(self, tab):
        # Todo: Print self, based on the depth of the node and  children
        print(tab * self.level, self.symbol, "Prob: " + str(self.weighted_probability))

        for key, child in self.children.items():
            if child is not None:
                child.print(tab)
        return


class Tree:
    def __init__(self, name, depth):
        self.name = name
        self.root = Node("root", None, self, 0)
        self.depth = depth

        if depth > 11:
            self.alpha = 0.05
        else:
            self.alpha = 0.5

    def read_weighted_probability(self, depth):
        """
        Will calculate and return the weighted probability of a CTW with given depth
        :param depth: The depth of the tree you want to read
        :return: A probability in log base 2 of the CTW of given depth
        """

        if depth > self.depth:
            return None
        if depth < 1:
            return None

        children_prob = 0
        for key, child in self.root.children.items():
            if child is not None:
                children_prob += child.get_weighted_prob(depth - 1)

        return children_prob + math.log(1 + pow(2, (self.root.estimated_probability - children_prob)), 2) + math.log(1 / 2, 2)

    def add_data_point(self, symbol, context):
        """Will add the data point to tree."""
        dirty_nodes = self.traverse_context(symbol, context)
        self.reweight_tree(dirty_nodes, symbol)
        self.add_inverted_point(symbol, context)

    def add_inverted_point(self, symbol, context):
        other_context = list(context)
        other_context.insert(0, symbol)
        # print(other_context);

        reverse = inverted_complement(other_context)
        new_symbol = reverse.pop(0)

        # print(reverse, "Symbol: ", new_symbol)

        dirty_nodes = self.traverse_context(new_symbol, reverse)
        self.reweight_tree(dirty_nodes, new_symbol)

    def read_file(self, file):

        file_seq = file.seq

        print(file_seq)

        context = []

        for index, symbol in enumerate(file_seq):
            if len(context) is not self.depth:
                #  Add to the context
                context.insert(0, symbol)
            else:
                #  Add to the tree
                # print("context: ", context)
                # print("symbol: ", symbol)

                self.add_data_point(symbol, context)

                context.pop()
                context.insert(0, symbol)

    def reweight_tree(self, dirtynodes, symbol):

        self.root.counts[symbol] += 1

        for node in dirtynodes:
            node.update_probability_log(symbol)

        self.root.update_probability_log(symbol)

    def traverse_context(self, symbol, context):
        # Start at the root
        current_node = self.root
        full_path = ""
        dirty_nodes = []
        depth = 1
        # For Each symbol in the context, traverse down from the root.
        for sym in context:

            full_path += sym
            if current_node.children[sym] is not None:
                current_node = current_node.children[sym]
            else:
                current_node.children[sym] = Node(sym, current_node, current_node.tree, depth)
                current_node = current_node.children[sym]
            depth += 1
            dirty_nodes.insert(0, current_node)
            current_node.counts[symbol] += 1

        return dirty_nodes

    def print(self, tab):
        print("Root: ", self.root.weighted_probability, " ", self.root.counts)

        for key, child in self.root.children.items():
            if child is not None:
                child.print(tab)

    def commands(self, command):
        # Adds a random sequence to the tree
        if command == "r" or command == "R":
            print("    Random:")
            context = []
            for x in range(0, self.depth):
                context.append(random.randint(1, 4))
            context = int_to_ACGT(context)
            symbol = num_to_ACGT(random.randint(1, 4))
            print(context, "  symbol: ", symbol)
            self.add_data_point(symbol, context)

        # Print out the tree
        elif command == "p" or command == "P":
            print("     Print:")
            self.print(input('     Enter your tab char: '))

        elif command == "l" or command == "L":
            print("Loading a file: ")
            # TODO: Add in a way to manage the records, so to load a specific record

            filename = askopenfilename()
            print(filename)

            file_extension = filename.split(".")[-1]
            iterator = None

            if file_extension == "gbk":
                iterator = SeqIO.parse(filename, "genbank")
            elif file_extension == "gz":
                handle = gzip.open(filename, "rt")
                iterator = SeqIO.parse(handle, "genbank")

            record = next(iterator)
            print(record.seq)

            self.read_file(record)

            iterator.close()

        elif command == "c" or command == "C":
            print_tree_commands()


class Competition:
    def __init__(self, max_depth, blocksize=200):
        self.max_depth = max_depth
        self.trees = dict()
        self.tree = Tree("MD:" + str(max_depth), max_depth)
        self.blocksize = blocksize

        for i in range(1, max_depth):
            self.trees[i] = Tree("Depth: " + str(i), i)
        #  Useful to have to a list of all the roots of the trees.
        #  This allows for easy comparisons between root probability values
        self.roots = dict()

        for key, value in self.trees.items():
            self.roots[key] = value.root

    def read_block(self, block):
        context = []
        previous_root_prob = dict()
        root_prob = dict()

        for x in range(1, self.max_depth):
            previous_root_prob[str(x)] = self.tree.read_weighted_probability(x)

        for index, symbol in enumerate(block):
            if len(context) is not self.max_depth:
                #  Add to the context
                context.insert(0, symbol)
            else:
                #  Add to the tree
                #  print("context: ", context)
                #  print("symbol: ", symbol)

                # Add to all to trees
                self.add_to_all(symbol, context)

                context.pop()
                context.insert(0, symbol)

        difference = dict()
        for x in range(1, self.max_depth):
            root_prob[str(x)] = self.tree.read_weighted_probability(x)
            difference[str(x)] = root_prob[str(x)] - previous_root_prob[str(x)]

        # print( "\n",previous_root_prob, "\n")
        # print(root_prob, "\n")
        # print(difference, "\n")
        # print("MAX: ", max(difference))
        # print("MIN: ", min(difference))

        return max(difference, key=difference.get), difference[max(difference, key=difference.get)]

    def add_to_all(self, symbol, context_full):
        #  sys.stdout.write("\rAdding symbol: %s With context: %s " % (symbol, context_full))
        self.tree.add_data_point(symbol, context_full)

    def read_file(self, file_handle):
        records = dict()

        for r in SeqIO.parse(file_handle, "gb"):
            records[r.id] = r.seq

        for key, value in records.items():
            sys.stdout.write("\r Record ID: %s, length: %s" % (key, str(len(value))))
        print("\n")

        file_seq = records["NW_004929429.1"]
        # TODO: Add a counter for the block size, so that it will send only the correct sized block
        # TODO: Add a list, of the/dic/something to keep track of best depth and its value

        block = list()
        blockseq = list()
        symcounter = 0

        for index, symbol in enumerate(file_seq):
            printProgressBar(symcounter, 40000)

            if symbol is "N":
                continue

            if symcounter > 40000:
                break

            block.append(symbol)
            symcounter += 1

            if len(block) is self.blocksize:
                blockseq.append(self.read_block(block))
                del block[:]

        print('\n', len(blockseq))
        print_to_file(blockseq)


def print_to_file(output, file="out.txt"):
    with open(file, 'w') as f:
        out = ""
        for item in output:
            out += str(item[0]) + ", " + str(item[1]) + "; \n"
        f.write(out)


def int_to_ACGT(int_list):
    """Helper Function - Allows for the randomly generated sequence to be converted into chars"""
    ACGT_list = []
    for x in int_list:
        if x == 1:
            ACGT_list.append("A")
        elif x == 2:
            ACGT_list.append("C")
        elif x == 3:
            ACGT_list.append("G")
        elif x == 4:
            ACGT_list.append("T")

    return ACGT_list


def printProgressBar (iteration, total, prefix = '', suffix = '', decimals = 3, length = 100, fill = '█'):
    """
    Call in a loop to create terminal progress bar
    @params:
        iteration   - Required  : current iteration (Int)
        total       - Required  : total iterations (Int)
        prefix      - Optional  : prefix string (Str)
        suffix      - Optional  : suffix string (Str)
        decimals    - Optional  : positive number of decimals in percent complete (Int)
        length      - Optional  : character length of bar (Int)
        fill        - Optional  : bar fill character (Str)
    """
    percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
    filledLength = int(length * iteration // total)
    bar = fill * filledLength + '-' * (length - filledLength)
    sys.stdout.write('\r%s |%s| %s%% %s' % (prefix, bar, percent, suffix))
    # Print New Line on Complete
    if iteration == total:
        print()

def num_to_ACGT(x):
    if x == 1:
        return "A"
    elif x == 2:
        return "C"
    elif x == 3:
        return "G"
    elif x == 4:
        return "T"


def print_trees(trees):
    print("\n Listing all current trees: ")
    print("\t Name:", "\t Depth", "\t\t| Root Prob.|\t\t Counts")
    print("\t ____________________________________________________")
    for key in trees:
        print("\t", key, "\t \t", trees[key].depth,
              "\t\t", trees[key].root.weighted_probability,
              "\t\t",  trees[key].root.counts)


def inverted_complement(symbols):
    reverse = [None] * len(symbols)

    for i, sym in enumerate(symbols):
        if sym == "A":
            reverse[i] = "T"
        elif sym == "T":
            reverse[i] = "A"
        elif sym == "G":
            reverse[i] = "C"
        elif sym == "C":
            reverse[i] = "G"

    reverse.reverse()
    return reverse


def main():
    # Allows for user input to interact with the functions above
    test_tree = Tree("Test", 5)

    trees = dict()
    print("Testing competition: ")
    test = Competition(16)

    handle = gzip.open("hs_alt_CHM1_1.1_chr22.gbk.gz", "rt")
    test.read_file(handle)
    # print_trees(test.trees)

    current_tree = test.tree

    trees[test_tree.name] = test_tree
    trees[test.tree.name] = test.tree

    # Table of commands
    print_commands()

    print_trees(trees)


    while 1:

        if current_tree is None:

            command = input('Enter your command: ')
            if command == "a":
                tree_name = input("Name of the new tree: ")
                depth_name = input("Depth:")
                trees[tree_name] = Tree(tree_name, int(depth_name))
                print_trees(trees)

            elif command == "o":
                name = input("\tWhich tree do you want to open?\n\t")
                current_tree = trees[name]
                print_tree_commands()

            elif command == "s":
                print_trees(trees)

            elif command == "d":
                name = input("\tWhich tree do you want to remove?\n\t")
                trees.pop(name, None)
                print_trees(trees)

            elif command == "c":
                print_commands()

        else:
            print("\n Currently in tree: ", current_tree.name)
            command = input("\t Enter your command: ")

            if command is "b":
                depth = input("what max depth do you want to calculate for? \n")
                if depth.isdigit():
                    for x in range(1, int(depth) + 1):
                        print(str(x) + ": ", current_tree.read_weighted_probability(int(x)))

            if command is "x" or command is "X":
                current_tree = None
                print_trees(trees)

            else:
                current_tree.commands(command)


if __name__ == "__main__": main()
